% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode,linktoc=all}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  a4paper,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Pattern Matching and Substitution in bash},
  pdfauthor={R (Chandra) Chandrasekhar},
  pdflang={en-GB},
  colorlinks=true,
  linkcolor={DarkOliveGreen},
  filecolor={Purple},
  citecolor={DarkKhaki},
  urlcolor={Maroon},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=25mm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{48,48,48}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.81,0.69}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{\textbf{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.94,0.87,0.69}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.87,0.87,0.75}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.86,0.86,0.80}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.76,0.75,0.62}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.75,0.75,0.82}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.94,0.94,0.56}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.94,0.87,0.69}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.94,0.94,0.82}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.94,0.94,0.56}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{1.00,0.81,0.69}{\textbf{#1}}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{british}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
% $HOME/.pandoc/defaults/latex-header-includes.tex
% Common header includes for both lualatex and xelatex engines.
%
% Preliminaries
%
% \PassOptionsToPackage{rgb,dvipsnames,svgnames}{xcolor}
% \PassOptionsToPackage{main=british}{babel}
\AtBeginEnvironment{quote}{\small}
\AtBeginEnvironment{quotation}{\small}
\AtBeginEnvironment{longtable}{\centering}
%
% Packages that are useful to include
%
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[inkscapeversion=1]{svg}
\usepackage[defaultlines=4,all]{nowidow}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{etoolbox}
\usepackage{fontsize}
\usepackage{newunicodechar}
\usepackage{pdflscape}
\usepackage{fnpct}
\usepackage{parskip}
  \setlength{\parindent}{0pt}
\usepackage[style=american]{csquotes}
% \usepackage{setspace} Use the <fontname-plus.tex> files for setspace
%
% noto-plus.tex
% Font-setting header file for use with Pandoc Markdown
% to generate PDF via LuaLaTeX.
% The main font is Noto Serif.
% Other main fonts are also available in appropriately named file.
\usepackage{fontspec}
\usepackage{setspace}
\setstretch{1.3}
%
\defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase,Renderer=Node} % at the start always
%
% For English
% See also https://tex.stackexchange.com/questions/574047/lualatex-amsthm-polyglossia-charissil-error
% We use Node as Renderer for the Latin Font and Greek Font and HarfBuzz as renderer ofr Indic fonts.
%
\babelfont{rm}[Script=Latin,Scale=1]{NotoSerif}% Config is at $HOME/texmf/tex/latex/NotoSerif.fontspec
%
\babelfont{sf}[Script=Latin]{SourceSansPro}% Config is at $HOME/texmf/tex/latex/SourceSansPro.fontspec
%
\babelfont{tt}[Script=Latin]{FiraMono}% Config is at $HOME/texmf/tex/latex/FiraMono.fontspec
%
% Sanskrit, Tamil, and Greek fonts
%
\babelprovide[import, onchar=ids fonts]{sanskrit}
\babelprovide[import, onchar=ids fonts]{tamil}
\babelprovide[import, onchar=ids fonts]{greek}
%
\babelfont[sanskrit]{rm}[Scale=1.1,Renderer=HarfBuzz,Script=Devanagari]{NotoSerifDevanagari}
\babelfont[sanskrit]{sf}[Scale=1.1,Renderer=HarfBuzz,Script=Devanagari]{NotoSansDevanagari}
\babelfont[tamil]{rm}[Renderer=HarfBuzz,Script=Tamil]{NotoSerifTamil}
\babelfont[tamil]{sf}[Renderer=HarfBuzz,Script=Tamil]{NotoSansTamil}
\babelfont[greek]{rm}[Script=Greek]{GentiumBookPlus}
%
% Math font
%
\usepackage{unicode-math} % seems not to hurt % fallabck
\setmathfont[bold-style=TeX]{STIX Two Math}
%
%
% Other fonts
%
\newfontfamily{\emojifont}{Symbola}
%

\usepackage{titling}
\usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhead{}
    \fancyfoot{}
    \renewcommand{\headrulewidth}{0.2pt}
    \renewcommand{\footrulewidth}{0.2pt}
    \fancyhead[LO,RE]{\scshape\thetitle}
    \fancyfoot[CO,CE]{\footnotesize Copyright © 2006\textendash\the\year, R (Chandra) Chandrasekhar}
    \fancyfoot[RE,RO]{\thepage}
\newfontfamily{\regulariconfont}{Font Awesome 6 Free Regular}[Color=Grey]
\newfontfamily{\solidiconfont}{Font Awesome 6 Free Solid}[Color=Grey]
\newfontfamily{\brandsiconfont}{Font Awesome 6 Brands}[Color=Grey]
%
% Direct input of Unicode code points
%
\newcommand{\faEnvelope}{\regulariconfont\ ^^^^f0e0\normalfont}
\newcommand{\faMobile}{\solidiconfont\ ^^^^f3cd\normalfont}
\newcommand{\faLinkedin}{\brandsiconfont\ ^^^^f0e1\normalfont}
\newcommand{\faGithub}{\brandsiconfont\ ^^^^f09b\normalfont}
\newcommand{\faAtom}{\solidiconfont\ ^^^^f5d2\normalfont}
\newcommand{\faPaperPlaneRegular}{\regulariconfont\ ^^^^f1d8\normalfont}
\newcommand{\faPaperPlaneSolid}{\solidiconfont\ ^^^^f1d8\normalfont}

%
% The block below is commented out because of Tofu glyphs in HTML
%
% \newcommand{\faEnvelope}{\regulariconfont\ \normalfont}
% \newcommand{\faMobile}{\solidiconfont\ \normalfont}
% \newcommand{\faLinkedin}{\brandsiconfont\ \normalfont}
% \newcommand{\faGithub}{\brandsiconfont\ \normalfont}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Pattern Matching and Substitution in \texttt{bash}}
\author{R (Chandra) Chandrasekhar}
\date{2023-02-28 | 2023-03-12}

\begin{document}
\maketitle

\thispagestyle{empty}


\hypertarget{the-arcane-powers-of-the-bash-shell}{%
\subsection{\texorpdfstring{The
\href{https://www.thefreedictionary.com/arcane}{arcane} powers of the
\texttt{bash}
shell}{The arcane powers of the bash shell}}\label{the-arcane-powers-of-the-bash-shell}}

The programs, \href{https://www.gnu.org/software/sed/}{\texttt{sed}},
\href{https://www.grymoire.com/Unix/Awk.html}{\texttt{awk}},
\href{https://www.gnu.org/software/grep/manual/grep.html}{\texttt{grep}},
and
\href{https://learnbyexample.github.io/learn_perl_oneliners/line-processing.html}{\texttt{perl}}
have been the traditionally used tools for matching and manipulating
lines and strings in Linux. But the
\href{https://www.gnu.org/software/bash/}{\texttt{bash} shell}
{[}\protect\hyperlink{ref-newham2005}{1},
\protect\hyperlink{ref-ryder2018}{2}{]} also embodies powerful
pattern-matching and substitution capabilities
{[}\protect\hyperlink{ref-parametersubs}{3}--\protect\hyperlink{ref-stringops}{6}{]},
many of which are relatively unknown and unused. This blog gives
practical examples for using these powerful, but somewhat understated
features, to achieve common tasks efficiently and tersely, directly from
within \texttt{bash} itself.

\hypertarget{extended-globbing}{%
\subsubsection{Extended globbing}\label{extended-globbing}}

\href{https://en.wikipedia.org/w/index.php?title=Glob_(programming)\&oldid=1133836865}{\emph{Globbing}}
is the unflattering term---an abbreviation for \emph{global}---used to
denote an operation to extract files satisfying certain conditions
{[}\protect\hyperlink{ref-glob2023}{7}--\protect\hyperlink{ref-globhistory}{9}{]}.
It is applicable also to the \texttt{bash} command line. For our
purposes, depending on the sort of matching we perform, it will be
sometimes necessary to set \texttt{shopt\ -s\ extglob} after the
\href{https://en.wikipedia.org/wiki/Shebang_(Unix)}{shebang} line
{[}\protect\hyperlink{ref-extglob}{10}{]}.

\hypertarget{parsing-filenames}{%
\subsection{Parsing filenames}\label{parsing-filenames}}

A fully qualified filename consists of a \texttt{path}, a
\texttt{basename}, and an \texttt{extension}. While not all filenames
are encountered in their full glory, it helps to decompose any given
filename into its constituent parts to help with housekeeping functions
on a machine running \texttt{bash}---for example, to facilitate
searching, sorting, renamimg, and other file-related functions.

\hypertarget{the-canonical-filename}{%
\subsubsection{The canonical filename}\label{the-canonical-filename}}

A \href{https://www.thefreedictionary.com/canonical}{canonical} filename
should comprise these components:

\begin{enumerate}
\tightlist
\item
  a \emph{path} with the forward slash \texttt{/} as the
  separator\footnote{The separator in Microsoft Windows is a
    \emph{backslash}, \texttt{\textbackslash{}}, but since we are
    discussing \texttt{bash}, running on Linux machines, it is the
    \emph{forward slash}, \texttt{/}, that is our character of interest.}
  between elements denoting the path;
\item
  a \emph{filename} in two parts:

  \begin{enumerate}
  \def\labelenumii{(\alph{enumii})}
  \tightlist
  \item
    comprising a \emph{basename} which appears immediately after the
    \emph{last} \texttt{/} character; and
  \item
    a \emph{file extension} that occurs after the basename and
    immediately after a \texttt{.} or period character.
  \end{enumerate}
\end{enumerate}

\texttt{/my\_path/is/quite/long/basename.ext} is a canonical
filename---hereafter referred to as \texttt{fullname}---where the
above-named structural elements are as follows:

\begin{enumerate}
\tightlist
\item
  path: \texttt{/my\_path/is/quite/long}
\item
  basename: \texttt{basename}
\item
  extension: \texttt{ext}
\item
  filename: \texttt{basename.ext}
\end{enumerate}

\hypertarget{parsing-the-fullname}{%
\subsubsection{\texorpdfstring{Parsing the
\texttt{fullname}}{Parsing the fullname}}\label{parsing-the-fullname}}

Our next task is to dissect the canonical filename into its above
components using pattern-matching in \texttt{bash}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\# file{-}parse.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"/my\_path/is/quite/long/basename.ext"}
\BuiltInTok{echo} \StringTok{"fullname is }\VariableTok{$fullname}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $path}
\CommentTok{\# Approach from the right until the \_first\_ \textasciigrave{}/\textasciigrave{}}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_right\_ end up to and including that \textasciigrave{}/\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{path}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\%}\NormalTok{/}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"path is }\VariableTok{$path}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $filename}
\CommentTok{\# Approach from the left until the \_last\_ \textasciigrave{}/\textasciigrave{} character}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_left\_ end up to and including that \textasciigrave{}/\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{filename}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{/}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"filename is }\VariableTok{$filename}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $ext}
\CommentTok{\# Approach from the \_left\_ until the \_last\_ \textasciigrave{}.\textasciigrave{} character}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_left\_ end up to and including that last \textasciigrave{}.\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"extension is }\VariableTok{$ext}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $basename}
\CommentTok{\# This requires trimming strings from both}
\CommentTok{\# the left and the right of $fullname}
\CommentTok{\# and requires \_two\_ steps if we start with $fullname.}
\CommentTok{\#}
\CommentTok{\# Instead, we use $filename, which is already available,}
\CommentTok{\# and excise the extension to get $basename.}
\CommentTok{\#}
\CommentTok{\# For this, we approach from the \_right\_ until we encounter}
\CommentTok{\# the \_first\_ \textasciigrave{}.\textasciigrave{} character and throw away everything}
\CommentTok{\# from the \_right\_ up to and including that first \textasciigrave{}.\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{basename}\OperatorTok{=}\StringTok{"}\VariableTok{$\{filename}\OperatorTok{\%}\NormalTok{.}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"basename is }\VariableTok{$basename}\StringTok{"}
\end{Highlighting}
\end{Shaded}

\hypertarget{mnemonics-behind-the-and-symbols}{%
\subsubsection{\texorpdfstring{Mnemonics behind the \texttt{\#} and
\texttt{\%}
symbols}{Mnemonics behind the \# and \% symbols}}\label{mnemonics-behind-the-and-symbols}}

The use of the symbols \texttt{\#} and \texttt{\%} in the pattern
matching expressions might seem arbitrary or whimsical. For a start,
they do not conform to the usual delimiters \texttt{\^{}} and
\texttt{\$} for the beginning and end of a line or string.

One other point to keep in view constantly is to avoid looking at
\texttt{bash} pattern matching solely through the lens of
\href{https://www.regular-expressions.info/tutorial.html}{regular
expressions}
{[}\protect\hyperlink{ref-posixcharclass}{11}--\protect\hyperlink{ref-writeregexp}{13}{]}.
There are some similarities, but the two are not identical.

So,
\href{https://www.ldoceonline.com/dictionary/the-dope-on-somebody-something}{what's
the dope} on \texttt{\#} and \texttt{\%}? These two symbols have been
chosen for their near universal usage as a prefix and suffix
respectively. It is customary to write \texttt{\#1} for ``number one'',
and \texttt{20\%} for ``twenty percent'', where you will notice that the
\texttt{\#} is written as a \emph{prefix} and the \texttt{\%} is written
as a \emph{suffix} to the number.

In the \texttt{bash} pattern-matching we have encountered so far, we are
matching elements in a string, \emph{and throwing away the matching
portion}, using some known delimiter. When we match from the left, we
use \texttt{\#} because it is a prefix. Likewise, when we match from the
right, we use \texttt{\%}, which is a suffix. In both cases, we stop at
the first match from whichever direction we are starting the search for
the match. The single \texttt{\#} and \texttt{\%} therefore denote
\href{https://stackoverflow.com/questions/2301285/what-do-lazy-and-greedy-mean-in-the-context-of-regular-expressions}{lazy
matching}.

The symbol \texttt{\#\#} means we deal with the \emph{longest} substring
from the left that matches: a case of
\href{https://www.geeksforgeeks.org/perl-greedy-and-non-greedy-match/}{greedy
matching}. The same applies to \texttt{\%\%} where we stop at the
longest matching substring from the right.

If you look carefully, you will see that---apart from the anchor
character(s)---we do not care about what we are throwing away. We can
therefore denote these ``don't care'' characters with the \texttt{*},
which is a
\href{https://en.wikipedia.org/wiki/Wildcard_character}{wildcard} that
denotes zero or more characters. What \emph{is} important to us, though,
is the \emph{delimiter} that anchors the string that we are trimming
off.

This delimiting character will be placed to the right of the \texttt{*}
when used with \texttt{\#} or \texttt{\#\#}, and it will be placed to
the left of \texttt{*} when used with \texttt{\%} or \texttt{\%\%}. You
will notice that the \texttt{/} and \texttt{.} characters obey this
simple, logical placement rule in the code above. In both cases, the
anchoring delimiter is also trimmed off.

To summarize:

\begin{enumerate}
\tightlist
\item
  When we use \texttt{\#} or \texttt{\#\#}, we discard a substring to
  the left of the anchor; and
\item
  When we use \texttt{\%} or \texttt{\%\%}, we discard a substring to
  the right of the anchor.
\end{enumerate}

\hypertarget{minefields-to-beware-of}{%
\subsection{Minefields to beware of}\label{minefields-to-beware-of}}

The pattern-matching capabilities in \texttt{bash} throw up unexpected
results when the assumptions made above are not fulfilled. The structure
of the \texttt{fullname} is one such. What happens if our assumptions
are false?

\hypertarget{filenames-without-an-extension}{%
\subsection{Filenames without an
extension}\label{filenames-without-an-extension}}

There are occasions when, for a variety of reasons, filenames might not
have extensions. In such cases, we might rightfully expect the extension
to be a null or empty string. But is that what happens in practice? Let
us try a simple experiment. You could fire up a bash terminal and run
what follows interactively.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}
\VariableTok{fullname}\OperatorTok{=}\VariableTok{$HOME}\NormalTok{/myPDFfile}
\VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"Extension is }\VariableTok{$ext}\StringTok{"}
\end{Highlighting}
\end{Shaded}

The result is:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Extension}\NormalTok{ is /home/}\OperatorTok{\textless{}}\NormalTok{redacted}\OperatorTok{\textgreater{}}\NormalTok{/myPDFfile}
\end{Highlighting}
\end{Shaded}

Surely, you did not expect the extension to be the fullname of the file.
Yet, that is what we get. Though unexpected, is it yet logically
correct?

Imagine you are moving from left to right until you hit the \emph{last}
\texttt{.} character. When you do, you discard whatever is to the left
of the \texttt{.} along with that character itself. If there is no
\texttt{.} character, you do not stop and you do not discard anything.
So, you are left with what you started with. \emph{But, although
logical, that is not the intent.} The error arises from the unfulfilled
assumption that \texttt{fullname} contains a dot character, followed by
alphanumeric characters that denote the extension.

One way to overcome this issue is to test for a period or dot character
in the original \texttt{fullname} string
{[}\protect\hyperlink{ref-periodtest}{14}--\protect\hyperlink{ref-bashscriptpatmatch}{16}{]}.
If there is no \texttt{.} character, we set the extension to the empty
string. Otherwise, we set it to what we get by the pattern-matching we
have discussed. The corrected routine for the extension should thus run:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\# ext.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"/path/myPDFfile"}

\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$fullname}\StringTok{"} \OtherTok{=\textasciitilde{}} \DataTypeTok{\textbackslash{}.} \KeywordTok{]]}
\ControlFlowTok{then}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{else}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{ext}\OperatorTok{=}\StringTok{""}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"Extension is }\VariableTok{$ext}\StringTok{"}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{=\textasciitilde{}} sign is a \emph{regular
expression} operator that has been inducted from \texttt{perl} into
\texttt{bash} {[}\protect\hyperlink{ref-equaltilde}{17}{]}. The
\texttt{{[}{[}...{]}{]}} expression returns a \texttt{0} for
\texttt{true} and a \texttt{1} for \texttt{false}, which may sound
contrary to expectations, but that is the correct behaviour in
\texttt{bash}. This may be seen by pre-pending
\href{https://stackoverflow.com/questions/6834487/what-is-the-dollar-question-mark-variable-in-shell-scripting}{\texttt{echo\ \$?}}
to each branch of the \texttt{if} conditional.

Moreover, when matching, the left side is a string that should be double
quoted to avoid errors, while the right side is a regular expression, or
a constant that is either escaped as in \texttt{\textbackslash{}.}, or
in single quotes, like \texttt{\textquotesingle{}.\textquotesingle{}}
{[}\protect\hyperlink{ref-dottest}{15}{]}. If a plain \texttt{.} is
used, with no ``protection'', it will match any single character in
accordance with regex rules, and we risk getting the wrong result. It is
attention to every small detail that ensures success with \texttt{bash}
scripts. You also learn patience on the way. \emojifont {😉} \normalfont

\hypertarget{filenames-with-multiple-dot-characters}{%
\subsubsection{Filenames with multiple dot
characters}\label{filenames-with-multiple-dot-characters}}

I have encountered occasions where the \texttt{fullname} of a file
contains multiple \texttt{.} characters. In such cases, we must adopt a
convention that the extension is what occurs to the \emph{right of the
rightmost} dot character. We will avoid pathological cases like a
filename \emph{ending} with a \texttt{.} character. If these additional
assumptions hold, our pattern-matching for the extension will return the
correct result.

\hypertarget{filenames-without-a-path}{%
\subsection{Filenames without a path}\label{filenames-without-a-path}}

Before attempting to extract a \texttt{path}, we must check for the
presence of a \texttt{/} in the \texttt{fullname} string. Otherwise, we
risk getting the same errors as with missing extensions. The following
script should be self-explanatory by now. Again, note that we either
need to make the \texttt{/} character a literal, enclosed by single
quotes, or we must escape it with a backslash,
\texttt{\textbackslash{}}. Note that this time, the forward slash is
enclosed by single quotes; I find \texttt{\textbackslash{}/} both
inelegant and somewhat perplexing.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\# path.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"myPDFfile.pdf"}

\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$fullname}\StringTok{"} \OtherTok{=\textasciitilde{}} \StringTok{\textquotesingle{}/\textquotesingle{}} \KeywordTok{]]}
\ControlFlowTok{then}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{path}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\%}\NormalTok{/}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{else}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{path}\OperatorTok{=}\StringTok{""}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"Path is }\VariableTok{$path}\StringTok{"}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-generalized-filename-parser}{%
\subsection{The generalized filename
parser}\label{the-generalized-filename-parser}}

The revised file for parsing a filename into its components therefore
needs to be augmented with these tests if it is to be robust and generic
{[}\protect\hyperlink{ref-caveats}{18}{]}. Note also that if no input is
given, there can be no meaningful output; so we have to test that there
is at least one command-line argument.

Because filename parsing is a task that I have had to do repeatedly in
different \texttt{bash} scripts, I decided that the final version of the
script should find expression as a \texttt{bash\ function} rather than
as a script.

Along the way, I encountered pitfalls and errors, too many to recount.
Suffice it to say that my helper and guide in the debugging process has
been the \href{https://www.shellcheck.net/}{Shellcheck utility}
{[}\protect\hyperlink{ref-shellcheck}{19}{]}. The file
\href{scripts/parse_filename.sh}{\texttt{parse\_filename.sh}}\footnote{Beware
  that although I have liberally replaced characters unsuited to Linux
  filenames with a hyphen or dash, later in this blog, the \texttt{-}
  character \emph{cannot} be used in the names of variables, functions,
  and the filenames of functions in \texttt{bash}.} is made available
here for completeness without any warranties whatsoever.
\href{https://core.ac.uk/download/pdf/267973227.pdf}{The usual
disclaimers about software merchantability} are implicit!
\emojifont {😉} \normalfont

\hypertarget{prettifying-non-standard-filenames}{%
\subsection{Prettifying non-standard
filenames}\label{prettifying-non-standard-filenames}}

We have now concluded the first part of processing a filename, and are
ready to proceed to the second part, which is
\href{https://www.thefreedictionary.com/prettifying}{prettifying} a
filename. Although filenames containing spaces, tabs, and
non-alphanumeric characters \emph{can} be processed in Linux---when
enclosed by single quotes---the natural etiquette in Linux file naming
is not to use such non-standard characters.

But what happens if we are bequeathed files having such names? Renaming
them one-by-one, by hand, will be laborious and even impractical. How
may we automate the renaming of such files---to result in filenames that
are both meaningful and Linux-friendly? That is what will occupy us for
the rest of this blog.

\hypertarget{from-cacophony-to-harmony}{%
\subsection{From cacophony to harmony}\label{from-cacophony-to-harmony}}

The original file naming convention in Linux is that there will be
\emph{no spaces} or other non-alphanumeric characters, \emph{except for
the underscore} character \texttt{\_} in a filename\footnote{The
  \texttt{-} character (dash or hyphen) assumes many roles: as the
  \href{https://en.wikipedia.org/wiki/Standard_streams}{standard input
  and standard output}, as a prefix to an option for commands, as a
  range specifier in regular expressions like \texttt{{[}a-z{]}}, etc.
  So, a filename should not start or end with the \texttt{-} character;
  its position elsewhere in a filename should not cause problems.}
{[}\protect\hyperlink{ref-unix}{20}{]}. This is because spaces are used
as input field separators (IFS) to break up a string into its
components: something known as
\href{https://mywiki.wooledge.org/WordSplitting?highlight=\%28spaces\%29\%7C\%28word\%29\%7C\%28splitting\%29}{\emph{word
splitting}} {[}\protect\hyperlink{ref-wordsplitting}{21}{]}.

But not all filenames respect this nomenclature of alphanumeric plus
underscore characters alone. What if you encountered a file named so:
\texttt{El??Condor\ \ \ \_Pasa\%\^{}!.mp3}. How would you sanitize it
into something that could be easily processed by Linux when supplied as
an argument?

This set me developing a simple script to convert all non-compatible
characters into acceptable characters so that the end result would be a
sanitized, Linux-compatible filename that still retained some of its
meaning. Here is my thought process as an algorithm:

\begin{enumerate}
\tightlist
\item
  Retain underscores \texttt{\_} unchanged;
\item
  Replace every other non-alphanumeric character by a \texttt{-}; and
\item
  Replace strings of consecutive \texttt{-} characters from the previous
  step by a single \texttt{-} character.
\item
  Neither the first nor the last character of the modified filename
  shall be a \texttt{-} character.
\end{enumerate}

The standard and most obvious way to do this is by using regular
expressions and a tool such as
\href{https://www.grymoire.com/Unix/Sed.html}{\texttt{sed}},
\href{https://tldp.org/LDP/abs/html/awk.html}{\texttt{awk}}, or
\href{https://perldoc.perl.org/perlretut}{\texttt{perl}}. Moreover, the
\href{https://www.regular-expressions.info/posixbrackets.html}{POSIX
character classes} such as \texttt{{[}:space:{]}},
\texttt{{[}:blank:{]}}, \texttt{{[}:punct:{]}} hold the key to concisely
including all characters that need to be substituted with dashes. This
was the trajectory I followed initially.

\hypertarget{using-sed-to-sanitize-a-filename}{%
\subsection{\texorpdfstring{Using \texttt{sed} to sanitize a
filename}{Using sed to sanitize a filename}}\label{using-sed-to-sanitize-a-filename}}

How might the unusual filename (or string)

\texttt{El??Condor\ \ \ \_Pasa\%\^{}!.mp3}

which contains three spaces, and five punctuation characters, be
sanitized using \texttt{sed}\footnote{The underscore does not count as a
  punctuation character because it is not replaced.}?

Typically, \texttt{sed} works on text within a file. But we may also
pass strings to \texttt{sed} as
\href{https://www.baeldung.com/linux/sed-with-string}{literals rather
than an input file}. Rather than stumble through the tedious path I took
to success, I record below the final
\href{https://catonmat.net/sed-one-liners-explained-part-one}{\texttt{sed}
one-liner} that I assembled. Note that we will henceforth use only the
basename of this filename in all examples.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}r} \StringTok{"s/([[:space:]]|[[:punct:]])+/{-}/g"} \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

which gives the result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{El{-}Condor{-}Pasa{-}}
\end{Highlighting}
\end{Shaded}

Note that \emph{multiple} spaces and punctuation characters have been
replaced by \emph{single} hyphens or dashes. The \texttt{+} sign in the
expression confers this behaviour. The fact that we want to change
\emph{both} spaces and punctuation is the reason for the
\texttt{\textbar{}} alternation sign which might be loosely looked at as
a logical \textsc{or}. The \texttt{g} parameter at the end (for global)
means that \emph{all} such occurrences will be substituted. The
\texttt{{[}{[}:space:{]}{]}} and \texttt{{[}{[}:punct:{]}{]}}
incantations are called
\href{https://www.regular-expressions.info/posixbrackets.html}{POSIX
character classes} {[}\protect\hyperlink{ref-posixcharclass}{11}{]}. The
option \texttt{-r} is given to \texttt{sed} to confer the regular
expression matching behaviour we are after. And the
\texttt{\textless{}\textless{}\textless{}} allows an input to be given
immediately to \texttt{sed} from the command line rather than from a
file. The \texttt{s} refers to a substitution.

But, are we satisfied with our result? Not really, on two counts:

\begin{enumerate}
\tightlist
\item
  We want to retain the underscore \texttt{\_} character unchanged, if
  and when it occurs in the original string. An underscore in our
  original string has disappeared.
\item
  We do not want a terminal hyphen in the modified filename, as in this
  case.
\end{enumerate}

The second is easier to fix first. We will resort to the start-of-line
anchor \texttt{\^{}} and the end-of-line anchor \texttt{\$} to eliminate
(possible) initial and terminal hyphens. Since \texttt{sed} can work
consecutively on the original string, or its modified variant, we can
simply chain the three substitutions using pipes so:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}E} \StringTok{"s/([[:space:]]|[[:punct:]])+/{-}/g"}  \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}} \KeywordTok{|} \DataTypeTok{\textbackslash{}}
\FunctionTok{sed} \StringTok{"s/\^{}{-}//"} \KeywordTok{|} \FunctionTok{sed}  \StringTok{"s/{-}$//"}
\end{Highlighting}
\end{Shaded}

to get

\begin{verbatim}
El-Condor-Pasa
\end{verbatim}

almost as desired. The \texttt{-E} option is POSIX-compliant and needed
to deal with extended regular expressions; in
\href{https://www.gnu.org/software/sed/manual/html_node/Command_002dLine-Options.html}{GNU
\texttt{sed}} it is synonymous with the \texttt{-r} option. The
\texttt{\textbar{}} character indicates that the input for the second
and third \texttt{sed} substitutions is the output from the previous
\texttt{sed} command. The \texttt{+} denotes multiple consecutive
instances of spaces and punctuation characters and the \texttt{g}
denotes performing the substitution globally, i.e., as many times as the
conditions require. The \texttt{//} means that there is no replacement
character.

The requirement to pass underscores unchanged is more serious, because
we need to modify the first \texttt{sed} replacement. Because the
\texttt{{[}{[}:punct:{]}{]}} class also includes the underscore
character, it is a sticky business to keep all the underscores but
replace every other punctuation symbol by a dash. In fact, it negates
the very notion and convenience of a POSIX character class.

What we want is some operation like a
\href{https://mathworld.wolfram.com/SetDifference.html}{set difference},
for which the regex syntax is not available for \texttt{sed}. One
\emph{could} enumerate all punctuation symbols and exclude only
\texttt{\_} from that list, and use that class instead of
\texttt{{[}{[}:punct:{]}{]}}, but this approach strikes me as
particularly
\href{https://idioms.thefreedictionary.com/Ham+Fisted}{ham-fisted}.

A better and more felicitous way is to invert the requirement and
\emph{preserve} the alphanumeric and underscore characters alone, and
\emph{replace everything else} by a dash:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}E} \StringTok{"s/([\^{}A{-}Za{-}z0{-}9\_])+/{-}/g"} \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}} \KeywordTok{|} \DataTypeTok{\textbackslash{}}
\FunctionTok{sed} \StringTok{"s/\^{}{-}//"} \KeywordTok{|} \FunctionTok{sed}  \StringTok{"s/{-}$//"}
\end{Highlighting}
\end{Shaded}

which gives:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{El{-}Condor{-}\_Pasa}
\end{Highlighting}
\end{Shaded}

Although it looks awkward---having a \texttt{-} followed by a
\texttt{\_}---this is exactly the desired output given our
transformation rules. Note that the \texttt{\^{}} character is used in
the first \texttt{sed} command as a \emph{negation} of a character
class, and in the second \texttt{sed} command as a start-of-string
anchor. It is this overloading of meanings on a single symbol that leads
to difficulties in understanding such expressions.

\hypertarget{can-it-be-done-in-bash}{%
\subsection{\texorpdfstring{Can it be done in
\texttt{bash}?}{Can it be done in bash?}}\label{can-it-be-done-in-bash}}

But what about the nagging refrain, ``Why not do it all in \texttt{bash}
itself, using pattern matching''? So, rather than considering how to do
this in \texttt{perl}, etc., I hacked my way through several iterations
of trying to perform the substitution in \texttt{bash} itself.

\hypertarget{pattern-matching-substitution-and-substring-removal}{%
\subsubsection{Pattern-matching, substitution, and substring
removal}\label{pattern-matching-substitution-and-substring-removal}}

The expression \texttt{{[}A-Za-z0-9\_{]}} has a rather fortuitous
abbreviation as a POSIX character class in \texttt{bash}: it is denoted
by \texttt{{[}{[}:word:{]}{]}}. The pattern-matching/replacement
expression in \texttt{bash} therefore becomes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}
\CommentTok{\#}
\VariableTok{filename}\OperatorTok{=}\StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}}
\CommentTok{\#}
\CommentTok{\# The character class \textasciigrave{}[:word:]\textasciigrave{} includes all}
\CommentTok{\# alphanumeric characters and the underscore.}
\CommentTok{\# \textasciigrave{}\^{}[:word:]\textasciigrave{} is the negation of this condition.}
\CommentTok{\# So, we replace \_all\_ non{-}alphanumeric characters}
\CommentTok{\# and non{-}underscores with the dash.}
\CommentTok{\#}
\CommentTok{\# The \textasciigrave{}+\textasciigrave{} sign though placed at the beginning rather than the end}
\CommentTok{\# has the same meaning as in the \textasciigrave{}sed\textasciigrave{} expression.}
\CommentTok{\# The \textasciigrave{}//\textasciigrave{} after $filename denotes multiple replacements}
\CommentTok{\# just like the terminal \textasciigrave{}g\textasciigrave{} in the \textasciigrave{}sed\textasciigrave{} substitution expression.}
\CommentTok{\#}
\VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{filename}\OperatorTok{//}\PreprocessorTok{+(}\SpecialStringTok{[\^{}[:word:]]}\PreprocessorTok{)}\OperatorTok{/}\NormalTok{{-}}\VariableTok{\}}\StringTok{"}
\CommentTok{\#}
\CommentTok{\# We then trim off the first character in $newname in case}
\CommentTok{\# it begins with a \textasciigrave{}{-}\textasciigrave{} character.}
\CommentTok{\# Nothing happens if the first character is not a \textasciigrave{}{-}\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{/\#}\SpecialStringTok{{-}}\VariableTok{\}}\StringTok{"}
\CommentTok{\#}
\CommentTok{\# Next, we trim off the last character in $newname}
\CommentTok{\# if it matches a dash.}
\CommentTok{\# Nothing happens if the last character is not a \textasciigrave{}{-}\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{\%}\NormalTok{{-}}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"}\VariableTok{$newname}\StringTok{"}
\end{Highlighting}
\end{Shaded}

It bears noting that in the last two expressions:

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\item
  there is no wildcard character \texttt{*} before the \texttt{-} in the
  first substring expression;
\item
  there is no wildcard character \texttt{*} after the \texttt{-} in the
  second substring expression;
\item
  consequently, in both cases, we are matching a \emph{single} initial
  or terminal\texttt{-} character, with no ill effects if either or both
  are missing; and
\item
  we may assign the possibly truncated variable \texttt{newname} to
  itself.
\end{enumerate}

We have accomplished what we set out to do with the filename. The
absence of the \texttt{*} in the expression
\texttt{newname="\$\{newname\%-\}"} has morphed the pattern matching and
substring removal we used for parsing filenames into a robust, removal
of a \emph{terminal} \texttt{-}, without the need to test if it is the
last character in the string. To demonstrate the terseness of this
approach, I give below the same operation, with a slightly longer
syntax, that is also available to us in \texttt{bash}.

\hypertarget{using-substring-extraction}{%
\subsubsection{Using substring
extraction}\label{using-substring-extraction}}

The syntax for substring extraction in \texttt{bash} is
\texttt{\$\{parameter:offset:length\}} where \texttt{offset} is measured
starting from \texttt{0} at the extreme left
{[}\protect\hyperlink{ref-parametersubs}{3},
\protect\hyperlink{ref-stringops}{6},
\protect\hyperlink{ref-substring}{22}{]}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}
\CommentTok{\#}
\VariableTok{filename}\OperatorTok{=}\StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}}
\CommentTok{\#}
\CommentTok{\# The character class [:word:] includes all}
\CommentTok{\# alphanumeric characters and the underscore.}
\CommentTok{\# \^{}[:word:] is the negation of this condition.}
\CommentTok{\# So, we replace all non{-}alphanumeric characters and non{-}underscores}
\CommentTok{\# with the dash.}
\CommentTok{\#}
\VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{filename}\OperatorTok{//}\PreprocessorTok{+(}\SpecialStringTok{[\^{}[:word:]]}\PreprocessorTok{)}\OperatorTok{/}\NormalTok{{-}}\VariableTok{\}}\StringTok{"}
\CommentTok{\#}
\CommentTok{\# Extract the first character in $newname and test if it is \textasciigrave{}{-}\textasciigrave{}.}
\CommentTok{\# If so, remove it; else do nothing.}
\CommentTok{\# Indexing starts with zero.}
\CommentTok{\#}
\VariableTok{firstchar}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{:}\DecValTok{0}\OperatorTok{:}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$firstchar}\StringTok{"} \OtherTok{==} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \KeywordTok{]]}
\ControlFlowTok{then}
  \VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{:}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"}\VariableTok{$newname}\StringTok{"}
\CommentTok{\#}
\CommentTok{\# Extract the last character in $newname and test if it is \textasciigrave{}{-}\textasciigrave{}.}
\CommentTok{\# If so, remove it; else do nothing.}
\CommentTok{\#}
\VariableTok{lastchar}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{:}\NormalTok{ {-}}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$lastchar}\StringTok{"} \OtherTok{==} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \KeywordTok{]]}
\ControlFlowTok{then}
  \VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{::}\NormalTok{{-}}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"}\VariableTok{$newname}\StringTok{"}
\end{Highlighting}
\end{Shaded}

The points to especially note here are:

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\item
  The expression \texttt{"\$\{newname:0:1\}"} denotes the substring of
  length 1 starting from the beginning of the string \texttt{\$newname}
  is obviously the first character in that string. It may also be
  written as \texttt{"\$\{newname::1\}"}.
\item
  There is a space between the \texttt{:} and the \texttt{-} in the
  expression \texttt{"\$\{newname:\ -1\}"}. This space is inserted to
  avoid ambiguity with \emph{another} expression of the form
  \texttt{\$\{parameter:-word\}} which has a different function. The
  \texttt{-1} in \texttt{"\$\{newname:\ -1\}"} denotes the leftmost
  character in the string. Another way to write this is as
  \texttt{"\$\{newname:0-1\}"}
  {[}\protect\hyperlink{ref-lastchar}{23}{]}. Still another equivalent
  expression is \texttt{"\$\{newname:(-1)\}"}.
\item
  The final idiom used above is \texttt{"\$\{newname::-1\}"}, which is
  shorthand for \texttt{"\$\{newname:0:-1\}"}. This operation strips off
  the final character in the variable \texttt{"\$\{newname\}"}. Because
  it is positional in nature, rather than the result of a pattern match,
  we have to test whether the terminal character is indeed a \texttt{-}.
\item
  We could also have used the \texttt{=\textasciitilde{}} sign for these
  tests since we are matching a \emph{single} character. Nevertheless,
  it is better programming discipline to test for equality when dealing
  with a single character, as it is more specific.
\end{enumerate}

It should be clear that the first version of substring extraction is
clearer, less verbose, and less prone to error than the second one.

\hypertarget{wrapping-it-all-up}{%
\subsection{Wrapping it all up}\label{wrapping-it-all-up}}

Because the simple filename cleanup attempted above is likely to find
repeated use, it seemed sensible to bundle these latter manipulations
into another function called
\href{scripts/prettify_filename.sh}{\texttt{prettify\_filename.sh}}.
Along with
\href{scripts/parse_filename.sh}{\texttt{parse\_filename.sh}}, these two
functions may be used from within a third script file as long as they
are invoked with a \texttt{source} command. The script
\href{scripts/MyFileRename.sh}{\texttt{MyFileRename.sh}} is an example
of how these two functions may be used together. This triad of files,
then, gives a complete set of tools to automate the renaming of
problematic filenames in Linux.

The \texttt{parse\_filename} and \texttt{prettify\_filename} functions
invoke certain environment variables to allow terminal output in colour.
That functionality comes from a third \texttt{bash} function called
\href{scripts/colorize_terminal.sh}{\texttt{colorize\_terminal.sh}}. My
\texttt{\$HOME/.bashrc} file calls this function through the line

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{source} \StringTok{"}\VariableTok{$HOME}\StringTok{"}\NormalTok{/bin/colorize\_terminal.sh}
\end{Highlighting}
\end{Shaded}

to make coloured terminal output available to all scripts.

\hypertarget{to-explore-further}{%
\subsection{To explore further}\label{to-explore-further}}

The interested reader is referred to the
\href{https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html\#Shell-Parameter-Expansion}{official
documentation online} for a comprehensive explanation of the dazzling
features of \emph{parameter expansion}
{[}\protect\hyperlink{ref-shellparamexp}{24}{]} and \emph{substring
removal} {[}\protect\hyperlink{ref-wikisubstring}{25}{]} in
\texttt{bash}. For an admirable summary of features like parameter
expansion, do also visit the clear and comprehensive
\href{https://mywiki.wooledge.org/BashGuide/Parameters}{BashGuide
website}.

If you are familiar with \texttt{bash} but require an
\href{https://www.thefreedictionary.com/aide+memoire}{aide-mémoire} for
some aspect of string matching or manipulation, the section with the
heading
\href{https://wiki.bash-hackers.org/start\#recommended_shell_resources}{``Recommended
Shell resources''} is the best place to start your search
{[}\protect\hyperlink{ref-bhwstart}{26}{]}. It contains a wealth of
authoritative links that will speedily dispel your doubts, not to speak
of saving you time.

\hypertarget{feedback}{%
\subsection{Feedback}\label{feedback}}

Please \href{mailto:feedback.swanlotus@gmail.com}{email me} your
comments and corrections.

\noindent A PDF version of this article is
\href{./pattern-matching-in-bash.pdf}{available for download here}:

\begin{small}

\begin{sffamily}

\url{https://swanlotus.netlify.app/blogs/pattern-matching-in-bash.pdf}

\end{sffamily}

\end{small}

\hypertarget{bibliography}{%
\section*{References}\label{bibliography}}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\leavevmode\vadjust pre{\hypertarget{ref-newham2005}{}}%
\CSLLeftMargin{1. }%
\CSLRightInline{Cameron Newham and Bill Rosenblatt. \emph{Learning the
bash shell}. 3rd ed. O'Reilly, 2005. }

\leavevmode\vadjust pre{\hypertarget{ref-ryder2018}{}}%
\CSLLeftMargin{2. }%
\CSLRightInline{Ryder, Tom. \emph{Bash quick start guide: Get up and
running with shell scripting with bash}. Packt, 2018. }

\leavevmode\vadjust pre{\hypertarget{ref-parametersubs}{}}%
\CSLLeftMargin{3. }%
\CSLRightInline{Mendel Cooper. Parameter substitution. Online. 10 March
2014. {[}Accessed~4~March~2023{]}. Available from:
\url{https://tldp.org/LDP/abs/html/parameter-substitution.html}}

\leavevmode\vadjust pre{\hypertarget{ref-frazier2019}{}}%
\CSLLeftMargin{4. }%
\CSLRightInline{Mitch Frazier. Pattern matching in bash. Online. 15
April 2019. {[}Accessed~28~February~2023{]}. Available from:
\url{https://www.linuxjournal.com/content/pattern-matching-bash}}

\leavevmode\vadjust pre{\hypertarget{ref-gnupattern}{}}%
\CSLLeftMargin{5. }%
\CSLRightInline{---. Pattern matching. Online. 26 September 2022.
{[}Accessed~4~March~2023{]}. Available from:
\url{https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html}}

\leavevmode\vadjust pre{\hypertarget{ref-stringops}{}}%
\CSLLeftMargin{6. }%
\CSLRightInline{Cameron Newham and Bill Rosenblatt. String operators.
Online. 26 January 1998. {[}Accessed~4~March~2023{]}. Available from:
\url{https://www.oreilly.com/library/view/learning-the-bash/1565923472/ch04s03.html}}

\leavevmode\vadjust pre{\hypertarget{ref-glob2023}{}}%
\CSLLeftMargin{7. }%
\CSLRightInline{Wikipedia authors. Glob (programming). Online. 15
January 2023. {[}Accessed~28~February~2023{]}. Available from:
\url{https://en.wikipedia.org/w/index.php?title=Glob_(programming)\&oldid=1133836865}}

\leavevmode\vadjust pre{\hypertarget{ref-globbingref}{}}%
\CSLLeftMargin{8. }%
\CSLRightInline{Gilles Quénot. Unix. Run script across multiple dirs on
specific files, where pathname has regex. Online. 5 March 2023.
{[}Accessed~5~March~2023{]}. Available from:
\url{https://unix.stackexchange.com/a/738684/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-globhistory}{}}%
\CSLLeftMargin{9. }%
\CSLRightInline{---. History of bash globbing. Online. 10 June 2014.
{[}Accessed~5~March~2023{]}. Available from:
\url{https://unix.stackexchange.com/questions/136353/history-of-bash-globbing}}

\leavevmode\vadjust pre{\hypertarget{ref-extglob}{}}%
\CSLLeftMargin{10. }%
\CSLRightInline{Krzysztof Kowalczyk. Extended globbing. Online. 30
January 2023. {[}Accessed~6~March~2023{]}. Available from:
\url{https://www.programming-books.io/essential/bash/extended-globbing-7c7bf6bd68b64f0e919716228ef9f3df}}

\leavevmode\vadjust pre{\hypertarget{ref-posixcharclass}{}}%
\CSLLeftMargin{11. }%
\CSLRightInline{Jan Goyvaerts. Regex tutorial---POSIX bracket
expressions. Online. 22 November 2019. {[}Accessed~5~March~2023{]}.
Available from:
\url{https://www.regular-expressions.info/posixbrackets.html}}

\leavevmode\vadjust pre{\hypertarget{ref-introbashregex}{}}%
\CSLLeftMargin{12. }%
\CSLRightInline{Zach Gollwitzer. Intro to bash regular expressions.
Online. 21 October 2020. {[}Accessed~5~March~2023{]}. Available from:
\url{https://dev.to/zachgoll/intro-to-bash-regular-expressions-4d2p}}

\leavevmode\vadjust pre{\hypertarget{ref-writeregexp}{}}%
\CSLLeftMargin{13. }%
\CSLRightInline{Abhinav Tiwari. How to write regular
expressions?---GeeksforGeeks. Online. 2 March 2023.
{[}Accessed~5~March~2023{]}. Available from:
\url{https://www.geeksforgeeks.org/write-regular-expressions/}}

\leavevmode\vadjust pre{\hypertarget{ref-periodtest}{}}%
\CSLLeftMargin{14. }%
\CSLRightInline{Lmcanavals. Test if a string has a period in it with
bash. Online. 1 February 2013. {[}Accessed~4~March~2023{]}. Available
from: \url{https://unix.stackexchange.com/a/63374/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-dottest}{}}%
\CSLLeftMargin{15. }%
\CSLRightInline{Mark Byers. Test for a dot in bash. Online. 30 April
2010. {[}Accessed~4~March~2023{]}. Available from:
\url{https://stackoverflow.com/a/2745096}}

\leavevmode\vadjust pre{\hypertarget{ref-bashscriptpatmatch}{}}%
\CSLLeftMargin{16. }%
\CSLRightInline{Mark Reed. Bash script pattern matching. Online. 22 June
2017. {[}Accessed~5~March~2023{]}. Available from:
\url{https://stackoverflow.com/a/44688520}}

\leavevmode\vadjust pre{\hypertarget{ref-equaltilde}{}}%
\CSLLeftMargin{17. }%
\CSLRightInline{Kusalananda. Bash test: What does "=\textasciitilde" do?
Online. 17 January 2017. {[}Accessed~4~March~2023{]}. Available from:
\url{https://unix.stackexchange.com/a/340485/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-caveats}{}}%
\CSLLeftMargin{18. }%
\CSLRightInline{Geirha. How can i use parameter expansion? How can i get
substrings? How can i get a file without its extension, or get just a
file's extension? What are some good ways to do basename and dirname?
Online. 9 November 2021. {[}Accessed~9~March~2023{]}. Available from:
\url{http://mywiki.wooledge.org/BashFAQ/073}}

\leavevmode\vadjust pre{\hypertarget{ref-shellcheck}{}}%
\CSLLeftMargin{19. }%
\CSLRightInline{Koalaman, Vidar Holen aka. ShellCheck. Finds bugs in
your shell scripts. Online. 12 March 2023. {[}Accessed~12~March~2023{]}.
Available from: \url{https://www.shellcheck.net/}}

\leavevmode\vadjust pre{\hypertarget{ref-unix}{}}%
\CSLLeftMargin{20. }%
\CSLRightInline{Peek, Jerry, Todino, Grace and Strang, John.
\emph{Learning the UNIX operating system}. 5th ed. O'Reilly, 2002. }

\leavevmode\vadjust pre{\hypertarget{ref-wordsplitting}{}}%
\CSLLeftMargin{21. }%
\CSLRightInline{Aka Maarten Billemont, lhunath and Aka Greg Wooledge,
GreyCat. Word splitting. Online. 23 May 2018.
{[}Accessed~5~March~2023{]}. Available from:
\url{https://mywiki.wooledge.org/WordSplitting?highlight=\%28spaces\%29\%7C\%28word\%29\%7C\%28splitting\%29}}

\leavevmode\vadjust pre{\hypertarget{ref-substring}{}}%
\CSLLeftMargin{22. }%
\CSLRightInline{Linuxize. How to check if a string contains a substring
in bash. Online. 19 July 2019. {[}Accessed~4~March~2023{]}. Available
from:
\url{https://linuxize.com/post/how-to-check-if-string-contains-substring-in-bash/\#google_vignette}}

\leavevmode\vadjust pre{\hypertarget{ref-lastchar}{}}%
\CSLLeftMargin{23. }%
\CSLRightInline{thinker3. How to get the last character of a string in a
shell? Online. 9 July 2013. {[}Accessed~7~March~2023{]}. Available from:
\url{https://stackoverflow.com/a/21635778}}

\leavevmode\vadjust pre{\hypertarget{ref-shellparamexp}{}}%
\CSLLeftMargin{24. }%
\CSLRightInline{Chet Ramey. Bash reference manual: Shell parameter
expansion. Online. 22 September 2020. {[}Accessed~5~April~2023{]}.
Available from:
\url{https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html\#Shell-Parameter-Expansion}}

\leavevmode\vadjust pre{\hypertarget{ref-wikisubstring}{}}%
\CSLLeftMargin{25. }%
\CSLRightInline{---. Parameter expansion {[}bash hackers wiki{]}.
Online. 10 December 2021. {[}Accessed~5~March~2023{]}. Available from:
\url{https://wiki.bash-hackers.org/syntax/pe\#substring_removal}}

\leavevmode\vadjust pre{\hypertarget{ref-bhwstart}{}}%
\CSLLeftMargin{26. }%
\CSLRightInline{---. The bash hackers wiki: Recommended shell resources.
Online. 5 March 2023. {[}Accessed~5~March~2023{]}. Available from:
\url{https://wiki.bash-hackers.org/start\#recommended_shell_resources}}

\end{CSLReferences}



\end{document}
