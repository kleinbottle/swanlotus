% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode,linktoc=all}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  a4paper,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Pattern Matching and Substitution in bash},
  pdfauthor={R (Chandra) Chandrasekhar},
  pdflang={en-GB},
  colorlinks=true,
  linkcolor={DarkOliveGreen},
  filecolor={Purple},
  citecolor={DarkKhaki},
  urlcolor={Maroon},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=25mm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{48,48,48}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.81,0.69}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{\textbf{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.94,0.87,0.69}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.87,0.87,0.75}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.86,0.86,0.80}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.76,0.75,0.62}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.75,0.75,0.82}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.94,0.94,0.56}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.94,0.87,0.69}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.94,0.94,0.82}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.94,0.94,0.56}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{1.00,0.81,0.69}{\textbf{#1}}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.86,0.64,0.64}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.80,0.80,0.80}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.80,0.58,0.58}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.50,0.62,0.50}{\textbf{#1}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{british}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
% $HOME/.pandoc/defaults/latex-header-includes.tex
% Common header includes for both lualatex and xelatex engines.
%
% Preliminaries
%
% \PassOptionsToPackage{rgb,dvipsnames,svgnames}{xcolor}
% \PassOptionsToPackage{main=british}{babel}
\AtBeginEnvironment{quote}{\small}
\AtBeginEnvironment{quotation}{\small}
\AtBeginEnvironment{longtable}{\centering}
%
% Packages that are useful to include
%
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[inkscapeversion=1]{svg}
\usepackage[defaultlines=4,all]{nowidow}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{etoolbox}
\usepackage{fontsize}
\usepackage{newunicodechar}
\usepackage{pdflscape}
\usepackage{fnpct}
\usepackage{parskip}
  \setlength{\parindent}{0pt}
\usepackage[style=american]{csquotes}
% \usepackage{setspace} Use the <fontname-plus.tex> files for setspace
%
% noto-plus.tex
% Font-setting header file for use with Pandoc Markdown
% to generate PDF via LuaLaTeX.
% The main font is Noto Serif.
% Other main fonts are also available in appropriately named file.
\usepackage{fontspec}
\usepackage{setspace}
\setstretch{1.3}
%
\defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase,Renderer=Node} % at the start always
%
% For English
% See also https://tex.stackexchange.com/questions/574047/lualatex-amsthm-polyglossia-charissil-error
% We use Node as Renderer for the Latin Font and Greek Font and HarfBuzz as renderer ofr Indic fonts.
%
\babelfont{rm}[Script=Latin,Scale=1]{NotoSerif}% Config is at $HOME/texmf/tex/latex/NotoSerif.fontspec
%
\babelfont{sf}[Script=Latin]{SourceSansPro}% Config is at $HOME/texmf/tex/latex/SourceSansPro.fontspec
%
\babelfont{tt}[Script=Latin]{FiraMono}% Config is at $HOME/texmf/tex/latex/FiraMono.fontspec
%
% Sanskrit, Tamil, and Greek fonts
%
\babelprovide[import, onchar=ids fonts]{sanskrit}
\babelprovide[import, onchar=ids fonts]{tamil}
\babelprovide[import, onchar=ids fonts]{greek}
%
\babelfont[sanskrit]{rm}[Scale=1.1,Renderer=HarfBuzz,Script=Devanagari]{NotoSerifDevanagari}
\babelfont[sanskrit]{sf}[Scale=1.1,Renderer=HarfBuzz,Script=Devanagari]{NotoSansDevanagari}
\babelfont[tamil]{rm}[Renderer=HarfBuzz,Script=Tamil]{NotoSerifTamil}
\babelfont[tamil]{sf}[Renderer=HarfBuzz,Script=Tamil]{NotoSansTamil}
\babelfont[greek]{rm}[Script=Greek]{GentiumBookPlus}
%
% Math font
%
\usepackage{unicode-math} % seems not to hurt % fallabck
\setmathfont[bold-style=TeX]{STIX Two Math}
%
%
% Other fonts
%
\newfontfamily{\emojifont}{Symbola}
%

\usepackage{titling}
\usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhead{}
    \fancyfoot{}
    \renewcommand{\headrulewidth}{0.2pt}
    \renewcommand{\footrulewidth}{0.2pt}
    \fancyhead[LO,RE]{\scshape\thetitle}
    \fancyfoot[CO,CE]{\footnotesize Copyright © 2006\textendash\the\year, R (Chandra) Chandrasekhar}
    \fancyfoot[RE,RO]{\thepage}
\newfontfamily{\regulariconfont}{Font Awesome 6 Free Regular}[Color=Grey]
\newfontfamily{\solidiconfont}{Font Awesome 6 Free Solid}[Color=Grey]
\newfontfamily{\brandsiconfont}{Font Awesome 6 Brands}[Color=Grey]
%
% Direct input of Unicode code points
%
\newcommand{\faEnvelope}{\regulariconfont\ ^^^^f0e0\normalfont}
\newcommand{\faMobile}{\solidiconfont\ ^^^^f3cd\normalfont}
\newcommand{\faLinkedin}{\brandsiconfont\ ^^^^f0e1\normalfont}
\newcommand{\faGithub}{\brandsiconfont\ ^^^^f09b\normalfont}
\newcommand{\faAtom}{\solidiconfont\ ^^^^f5d2\normalfont}
\newcommand{\faPaperPlaneRegular}{\regulariconfont\ ^^^^f1d8\normalfont}
\newcommand{\faPaperPlaneSolid}{\solidiconfont\ ^^^^f1d8\normalfont}

%
% The block below is commented out because of Tofu glyphs in HTML
%
% \newcommand{\faEnvelope}{\regulariconfont\ \normalfont}
% \newcommand{\faMobile}{\solidiconfont\ \normalfont}
% \newcommand{\faLinkedin}{\brandsiconfont\ \normalfont}
% \newcommand{\faGithub}{\brandsiconfont\ \normalfont}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Pattern Matching and Substitution in \texttt{bash}}
\author{R (Chandra) Chandrasekhar}
\date{2023-02-28 | 2023-03-01}

\begin{document}
\maketitle

\thispagestyle{empty}


\hypertarget{the-arcane-powers-of-the-bash-shell}{%
\subsection{\texorpdfstring{The arcane powers of the \texttt{bash}
shell}{The arcane powers of the bash shell}}\label{the-arcane-powers-of-the-bash-shell}}

The \href{https://www.gnu.org/software/bash/}{\texttt{bash} shell}
{[}\protect\hyperlink{ref-newham2005}{15}{]} embodies powerful
pattern-matching and substitution capabilities, many of which are
relatively unknown
{[}\protect\hyperlink{ref-gnupattern}{1},\protect\hyperlink{ref-parametersubs}{7},\protect\hyperlink{ref-frazier2019}{13},\protect\hyperlink{ref-stringops}{14}{]}.
The programs, \href{https://www.gnu.org/software/sed/}{\texttt{sed}},
\href{https://www.grymoire.com/Unix/Awk.html}{\texttt{awk}},
\href{https://www.gnu.org/software/grep/manual/grep.html}{\texttt{grep}},
and
\href{https://learnbyexample.github.io/learn_perl_oneliners/line-processing.html}{\texttt{perl}}
have been traditionally used for matching and manipulating lines and
strings in Linux.

But the pattern-matching and string manipulation capabilities of
\texttt{bash} have grown steadily since version 2.02, which was released
in 1998. This blog gives practical examples for using these powerful,
but somewhat understated features, to achieve common tasks efficiently
and tersely, directly from within \texttt{bash} itself.

\hypertarget{parsing-filenames}{%
\subsection{Parsing filenames}\label{parsing-filenames}}

A fully qualified filename consists of a \texttt{path}, a
\texttt{basename}, and an \texttt{extension}. While not all filenames
are encountered in their full glory, it helps to decompose any given
filename into its constituent parts to help with housekeeping functions
on a machine running \texttt{bash}---for example, to facilitate
searching, sorting and other file-related functions.

\hypertarget{extended-globbing}{%
\subsubsection{Extended globbing}\label{extended-globbing}}

\href{https://en.wikipedia.org/w/index.php?title=Glob_(programming)\&oldid=1133836865}{\emph{Globbing}}
is the unflattering term---an abbreviation for \emph{global}---used to
denote an operation to extract files satisfying certain conditions
{[}\protect\hyperlink{ref-globhistory}{2},\protect\hyperlink{ref-globbingref}{16},\protect\hyperlink{ref-glob2023}{20}{]}.
It is applicable also to the \texttt{bash} command line. For our
purposes, it is useful and sometimes mandatory, to set
\texttt{shopt\ -s\ extglob} after the
\href{https://en.wikipedia.org/wiki/Shebang_(Unix)}{shebang} line.

\hypertarget{a-canonical-filename}{%
\subsubsection{A canonical filename}\label{a-canonical-filename}}

A \href{https://www.thefreedictionary.com/canonical}{canonical} filename
will comprise these components:

\begin{enumerate}
\tightlist
\item
  a \emph{path} with the forward slash \texttt{/} as the separator
  between elements denoting the path;
\item
  a \emph{filename} in two parts:

  \begin{enumerate}
  \def\labelenumii{(\alph{enumii})}
  \tightlist
  \item
    comprising a \emph{basename} which appears immediately after the
    \emph{last} \texttt{/} character; and
  \item
    a \emph{file extension} that occurs after the basename and
    immediately after a \texttt{.} or period character.
  \end{enumerate}
\end{enumerate}

\texttt{/my\_path/is/quite/long/basename.ext} is a canonical filename
where the abovenamed elements are as follows:

\begin{enumerate}
\tightlist
\item
  path: \texttt{/my\_path/is/quite/long}
\item
  basename: \texttt{basename}
\item
  extension: \texttt{ext}
\item
  filename: \texttt{basename.ext}
\end{enumerate}

\hypertarget{parsing-the-filename}{%
\subsubsection{Parsing the filename}\label{parsing-the-filename}}

Our next task is to dissect the canonical filename into its above
components using pattern-matching in \texttt{bash}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\#file{-}parse.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"/my\_path/is/quite/long/basename.ext"}
\BuiltInTok{echo} \StringTok{"fullname is }\VariableTok{$\{fullname\}}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $path}
\CommentTok{\# Approach from the right until the \_first\_ \textasciigrave{}/\textasciigrave{}}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_right\_ end up to and including that \textasciigrave{}/\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{path}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\%}\NormalTok{/}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"path is }\VariableTok{$\{fullname}\OperatorTok{\%}\NormalTok{/}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $filename}
\CommentTok{\# Approach from the left until the \_last\_ \textasciigrave{}/\textasciigrave{} character}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_left\_ end up to and including that \textasciigrave{}/\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{filename}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{/}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"filename is }\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{/}\VariableTok{\}}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $extension}
\CommentTok{\# Approach from the \_left\_ until the \_last\_ \textasciigrave{}.\textasciigrave{} character}
\CommentTok{\# is encountered and throw away everything}
\CommentTok{\# from the \_left\_ end up to and including that last \textasciigrave{}.\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"extension is }\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# Extract $basename}
\CommentTok{\# This requires trimming strings from both}
\CommentTok{\# the left and the right of \textasciigrave{}fullname\textasciigrave{}}
\CommentTok{\# and requires \_two\_ steps.}
\CommentTok{\#}
\CommentTok{\# Instead, we use \textasciigrave{}filename\textasciigrave{} which is already available,}
\CommentTok{\# and excise the extension.}
\CommentTok{\#}
\CommentTok{\# For this, we approach from the \_right\_ until we encounter}
\CommentTok{\# the \_first\_ \textasciigrave{}.\textasciigrave{} character and throw away everything}
\CommentTok{\# from the \_right\_ up to and including that first \textasciigrave{}.\textasciigrave{}.}
\CommentTok{\#}
\VariableTok{basename}\OperatorTok{=}\StringTok{"}\VariableTok{$\{filename}\OperatorTok{\%}\NormalTok{.}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"basename is }\VariableTok{$\{filename}\OperatorTok{\%}\NormalTok{.}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\end{Highlighting}
\end{Shaded}

\hypertarget{mnemonics-behind-the-and-symbols}{%
\subsubsection{\texorpdfstring{Mnemonics behind the \texttt{\#} and
\texttt{\%}
symbols}{Mnemonics behind the \# and \% symbols}}\label{mnemonics-behind-the-and-symbols}}

The use of the symbols \texttt{\#} and \texttt{\%} in the pattern
matching expressions might seem arbitrary or whimsical. For a start,
they do not conform to the usual delimiters \texttt{\^{}} and
\texttt{\$} for the beginning and end of a line. Because we are dealing
with strings rather than lines here, those symbols are not used.

One other point to keep in view constantly is to avoid looking at
\texttt{bash} pattern matching through the lens of
\href{https://www.regular-expressions.info/tutorial.html}{regular
expressions}
{[}\protect\hyperlink{ref-introbashregex}{8},\protect\hyperlink{ref-posixcharclass}{9},\protect\hyperlink{ref-writeregexp}{19}{]}.
There are some similarities, but the two are not identical.

So,
\href{https://www.ldoceonline.com/dictionary/the-dope-on-somebody-something}{what's
the dope} on \texttt{\#} and \texttt{\%}? These two symbols have been
chosen for their near universal usage as a prefix and suffix
respectively. It is customary to write \texttt{\#1} for ``number one'',
and \texttt{20\%} for ``twenty percent'', where you will notice that the
\texttt{\#} is written as a \emph{prefix} and the \texttt{\%} is written
as a \emph{suffix} to the number.

In the \texttt{bash} pattern-matching we have encountered so far, we are
matching elements in a string, \emph{and throwing away the matching
portion}, using some known delimiter. When we match from the left, we
use \texttt{\#} because it is a prefix. Likewise, when we match from the
right, we use \texttt{\%}, which is a suffix. In both cases, we stop at
the first match from whichever direction we are starting the search for
the match. The single \texttt{\#} and \texttt{\%} therefore denote
\href{https://stackoverflow.com/questions/2301285/what-do-lazy-and-greedy-mean-in-the-context-of-regular-expressions}{lazy
matching}.

The symbol \texttt{\#\#} means we deal with the \emph{longest} substring
from the left that matches: a case of
\href{https://www.geeksforgeeks.org/perl-greedy-and-non-greedy-match/}{greedy
matching}. The same applies to \texttt{\%\%} where we stop at the
longest matching substring from the right.

If you look carefully, you will see that---apart from the anchor
character(s)---we do not care about what we are throwing away. We can
therefore denote these ``don't care'' characters with the \texttt{*},
which is a
\href{https://en.wikipedia.org/wiki/Wildcard_character}{wildcard} that
denotes zero or more characters. What \emph{is} important to us, though,
is the \emph{delimiter} that anchors the string that we are trimming
off.

This delimiting character will be placed to the right of the \texttt{*}
when used with \texttt{\#} or \texttt{\#\#}, and it will be placed to
the left of \texttt{*} when used with \texttt{\%} or \texttt{\%\%}. You
will notice that the \texttt{/} and \texttt{.} characters obey this
simple, logical placement rule in the code above. In both cases, the
anchoring delimiter is also trimmed off.

To summarize:

\begin{enumerate}
\tightlist
\item
  When we use \texttt{\#} or \texttt{\#\#}, we discard a substring to
  the left of the anchor; and
\item
  When we use \texttt{\%} or \texttt{\%\%}, we discard a substring to
  the right of the anchor.
\end{enumerate}

\hypertarget{minefields-to-beware-of}{%
\subsection{Minefields to beware of}\label{minefields-to-beware-of}}

The pattern-matching capabilities in \texttt{bash} throw up unexpected
results when the assumptions made above are not fulfilled. The structure
of the \texttt{fullname} is one such. What happens if our assumptions
are false?

\hypertarget{filenames-without-an-extension}{%
\subsection{Filenames without an
extension}\label{filenames-without-an-extension}}

There are occasions when, for a variety of reasons, filenames might not
have extensions. In such cases, we might rightfully expect the extension
to be a null or empty string. But is that what happens in practice? Let
us try a simple experiment. You could fire up a bash terminal and run
what follows interactively.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}
\VariableTok{fullname}\OperatorTok{=}\VariableTok{$HOME}\NormalTok{/myPDFfile}
\VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\BuiltInTok{echo} \StringTok{"Extension is }\VariableTok{$ext}\StringTok{."}
\end{Highlighting}
\end{Shaded}

The result is:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{Extension}\NormalTok{ is /home/chandra/myPDFfile.}
\end{Highlighting}
\end{Shaded}

Surely, you did not expect the extension to be the fullname of the file.
Yet, that is what we get. Though unexpected, is it yet logically
correct?

Imagine you are moving from left to right until you hit the \emph{last}
\texttt{.} character. When you do, you discard whatever is to the left
of the \texttt{.} along with that character itself. If there is no
\texttt{.} character, you do not stop and you do not discard anything.
So, you are left with what you started with. \emph{But, although
logical, that is not the intent.}

One way to overcome this issue is to test for a period or dot character
in the original \texttt{fullname} string
{[}\protect\hyperlink{ref-dottest}{6},\protect\hyperlink{ref-periodtest}{12},\protect\hyperlink{ref-bashscriptpatmatch}{18}{]}.
If there is no \texttt{.} character, we set the extension to the empty
string. Otherwise, we set it to what we get by the pattern-matching we
have discussed. The corrected routine for the extension should thus run:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\# ext.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"/path/myPDFfile"}

\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$fullname}\StringTok{"} \OtherTok{=\textasciitilde{}} \DataTypeTok{\textbackslash{}.} \KeywordTok{]]}
\ControlFlowTok{then}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{ext}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\#\#}\PreprocessorTok{*}\NormalTok{.}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{else}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{ext}\OperatorTok{=}\StringTok{""}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"Extension is }\VariableTok{$ext}\StringTok{."}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{=\textasciitilde{}} sign is a \emph{regular
expression} operator that has been inducted into \texttt{bash}
{[}\protect\hyperlink{ref-equaltilde}{10}{]}. It returns a \texttt{0}
for \texttt{true} and a \texttt{1} for \texttt{false}, which may sound
contrary to expectations, but that is the correct behaviour. This may be
seen by appending \texttt{echo\ \$?} above to each branch of the
\texttt{if} conditional.

Moreover, when matching, the left side is double quoted while the right
side is either escaped as in \texttt{\textbackslash{}.} or is a literal,
like \texttt{\textquotesingle{}.\textquotesingle{}}
{[}\protect\hyperlink{ref-dottest}{6}{]}. If a plain \texttt{.} is used,
with no ``protection'', it will natch any character in accordance with
regex rules, and we risk getting the wrong result. It is attention to
every small detail that ensures success with \texttt{bash} scripts. In
the process, you also learn patience. \emojifont {😉} \normalfont

\hypertarget{filenames-with-multiple-dot-characters}{%
\subsubsection{Filenames with multiple dot
characters}\label{filenames-with-multiple-dot-characters}}

I have encountered occasions where the \texttt{fullname} of a file
contains multiple \texttt{.} characters. In such cases, we must adopt a
convention that the extension is what occurs to the \emph{right of the
rightmost} dot character. We will avoid pathological cases like a
filename \emph{ending} with a \texttt{.} character. If these additional
assumptions hold, our pattern-matching for the extension will return the
correct result.

\hypertarget{filenames-without-a-path}{%
\subsection{Filenames without a path}\label{filenames-without-a-path}}

Before attempting to extract a \texttt{path}, we must check for the
presence of a \texttt{/} in the \texttt{fullname} string. Otherwise, we
risk getting the same errors as with missing extensions. The following
script should be self-explanatory by now. Again, note that we either
need to make the \texttt{/} character a literal, enclosed by single
quotes, or we must escape it with a backslash. Note that this time,the
forward slash is enclosed by single quotes.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\CommentTok{\# path.sh}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{fullname}\OperatorTok{=}\StringTok{"myPDFfile.pdf"}

\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$fullname}\StringTok{"} \OtherTok{=\textasciitilde{}} \StringTok{\textquotesingle{}/\textquotesingle{}} \KeywordTok{]]}
\ControlFlowTok{then}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{path}\OperatorTok{=}\StringTok{"}\VariableTok{$\{fullname}\OperatorTok{\%}\NormalTok{/}\PreprocessorTok{*}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{else}
  \BuiltInTok{echo} \VariableTok{$?}
  \VariableTok{path}\OperatorTok{=}\StringTok{""}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"Path is }\VariableTok{$path}\StringTok{."}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-generalized-filename-parser}{%
\subsection{The generalized filename
parser}\label{the-generalized-filename-parser}}

The revised file for parsing a filename into its components therefore
needs to be augmented with these tests if it is to be robust and
general. Note also that if no input is given, there can be no meaningful
output. The file
\href{scripts/parsefilename.sh}{\texttt{parsefilename.sh}} embodies the
improvements we have discussed and is available here for completeness.

\hypertarget{prettifying-non-standard-filenames}{%
\subsection{Prettifying non-standard
filenames}\label{prettifying-non-standard-filenames}}

We have now concluded the first part of processing a filename, and are
ready to proceed to the second part, which is
\href{https://www.thefreedictionary.com/prettifying}{prettifying} a
filename. Although filenames containing spaces, tabs, and and
non-alphanumeric characters can be processed in Linux---when enclosed by
single quotes---the natural etiquette in Linux file naming is not to use
such non-standard characters.

But what happens if we are bequeathed files having such names? Renaming
them one-by-one by hand will be laborious and even impractical. How may
we automate the renaming of such files---to result in filenames that are
meaningful as well as Linux-friendly? That is what will occupy us for
the rest of this blog.

\hypertarget{from-cacophony-to-harmony}{%
\subsection{From cacophony to harmony}\label{from-cacophony-to-harmony}}

The file naming convention in Linux is that there will be no spaces or
other non-alphanumeric characters, \emph{except for the underscore}
character \texttt{\_} in a filename. This is because spaces are used as
input field separators (IFS) to break up a string into its components:
something known as
\href{https://mywiki.wooledge.org/WordSplitting?highlight=\%28spaces\%29\%7C\%28word\%29\%7C\%28splitting\%29}{\emph{word
splitting}} {[}\protect\hyperlink{ref-wordsplitting}{5}{]}.

But not all files respect this nomenclature of alphanumeric plus
underscore characters alone. What if you encountered a file named so:
\texttt{El??Condor\ \ \ \_Pasa\%\^{}!.mp3}. How would you sanitize it
into something that could be easily processed by Linux when supplied as
an argument?

This set me developing a simple script to convert all non-compatible
characters into acceptable characters so that the end result would be a
sanitized, Linux-compatible filename that still retained its meaning.
Here is my thought process as an algorithm:

\begin{enumerate}
\tightlist
\item
  Replace all non-standard characters with dashes \texttt{-}.
\item
  Replace consecutive spaces, or other non-alphanumeric characters, by a
  \emph{single} dash.
\item
  Retain underscores, \texttt{\_}, unchanged.
\end{enumerate}

The standard and most obvious way to do this is by using regular
expressions and a tool such as
\href{https://www.grymoire.com/Unix/Sed.html}{\texttt{sed}} or
\href{https://tldp.org/LDP/abs/html/awk.html}{\texttt{awk}} or
\href{https://perldoc.perl.org/perlretut}{\texttt{perl}}. Moreover, the
\href{https://www.regular-expressions.info/posixbrackets.html}{POSIX
character classes} such as \texttt{{[}:space:{]}},
\texttt{{[}:blank:{]}}, \texttt{{[}:punct:{]}} hold the key to concisely
including all characters that need to be substituted with dashes. This
was the trajectory I followed initially.

\hypertarget{using-sed-to-sanitize-a-filename}{%
\subsection{\texorpdfstring{Using \texttt{sed} to sanitize a
filename}{Using sed to sanitize a filename}}\label{using-sed-to-sanitize-a-filename}}

How might the pathological filename (or string)
\texttt{El??Condor\ \ \ \_Pasa\%\^{}!.mp3}---which contains spaces and
punctuation---be sanitized using \texttt{sed}?

Typically, \texttt{sed} works on text within a file. But we may also
pass strings to \texttt{sed} as
\href{https://www.baeldung.com/linux/sed-with-string}{literals rather
than an input file}. Rather than stumble through the tedious path I took
to success, I record below the final
\href{https://catonmat.net/sed-one-liners-explained-part-one}{\texttt{sed}
one-liner} that I assembled. Note that we will henceforth use only the
basename of this filename in all examples.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}r} \StringTok{"s/([[:space:]]|[[:punct:]])+/{-}/g"} \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

which gives the result:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{El{-}Condor{-}Pasa{-}}
\end{Highlighting}
\end{Shaded}

Note that \emph{multiple} spaces and punctuation characters have been
replaced by \emph{single} hyphens or dashes. The \texttt{+} sign in the
expression confers this behaviour. The fact that we want to change
\emph{both} spaces and punctuation is the reason for the
\texttt{\textbar{}} alternation sign which might be loosely looked at as
a logical \textsc{or}. The \texttt{g} parameter at the end (for global)
means that \emph{all} such occurrences will be substituted. The
\texttt{{[}{[}:space:{]}{]}} and \texttt{{[}{[}:punct:{]}{]}}
incantations are called
\href{https://www.regular-expressions.info/posixbrackets.html}{POSIX
character classes} {[}\protect\hyperlink{ref-posixcharclass}{9}{]}. The
option \texttt{-r} is given to \texttt{sed} to confer the regular
expression matching behaviour we are after. And the
\texttt{\textless{}\textless{}\textless{}} allows an input to be given
immediately to \texttt{sed} from the command line rather than from a
file.

Now, are we satisfied with our result? Not really, on two counts:

\begin{enumerate}
\tightlist
\item
  We want to retain the underscore \texttt{\_} character unchanged, if
  and when it occurs in the original string. An underscore in our
  original string has disappeared.
\item
  We do not want a terminal hyphen in the modified filename, as in this
  case.
\end{enumerate}

The second is easier to fix first. We will resort to the end-of-line
anchor \texttt{\$} to identify the terminal hyphen after the first
replacement. Since \texttt{sed} can work consecutively on the string, or
its modified variant, we can simply chain two substitutions using pipes
so:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}E} \StringTok{"s/([[:space:]]|[[:punct:]])+/{-}/g"}  \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}} \KeywordTok{|} \FunctionTok{sed}  \StringTok{"s/{-}$//"}
\end{Highlighting}
\end{Shaded}

to get

\begin{verbatim}
El-Condor-Pasa
\end{verbatim}

as desired. The \texttt{-E} option is POSIX-compliant and needed to deal
with extended regular expressions. In
\href{https://www.gnu.org/software/sed/manual/html_node/Command_002dLine-Options.html}{GNU
\texttt{sed}} it is synonymous with the \texttt{-r} option. The
\texttt{\textbar{}} character indicates that the input for this second
\texttt{sed} substitution is the output from the previous \texttt{sed}
command.

The requirement to pass underscores unchanged is more serious because we
need to modify the first \texttt{sed} replacement. Because the
\texttt{{[}{[}:punct:{]}{]}} class also includes the underscore
character, it is a sticky business to keep all the underscores but
replace every other punctuation symbol by a dash. In fact, it negates
the very notion of a POSIX character class.

What we want is some operation like a
\href{https://mathworld.wolfram.com/SetDifference.html}{set difference}
for which the regex syntax is not available for \texttt{sed}. One
\emph{could} enumerate all punctuation symbols and exclude only
\texttt{\_} from that list, and use that class instead of
\texttt{{[}{[}:punct:{]}{]}}, but this approach strikes me as grossly
inelegant.

A better and more felicitous way is to invert the requirement and
\emph{preserve} the alphanumeric and underscore characters alone, and
\emph{replace everything else} by a dash:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sed} \AttributeTok{{-}E} \StringTok{"s/([\^{}A{-}Za{-}z0{-}9\_])+/{-}/g"} \OperatorTok{\textless{}\textless{}\textless{}} \StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}} \KeywordTok{|} \FunctionTok{sed} \StringTok{"s/{-}$//"}
\end{Highlighting}
\end{Shaded}

which gives:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{El{-}Condor{-}\_Pasa}
\end{Highlighting}
\end{Shaded}

Although it looks awkward---having a \texttt{-} followed by a
\texttt{\_}---this is exactly the desired output given our
transformation rules. One caveat is that this expression will only work
with ASCII characters.

\hypertarget{can-it-be-done-in-bash}{%
\subsection{\texorpdfstring{Can it be done in
\texttt{bash}?}{Can it be done in bash?}}\label{can-it-be-done-in-bash}}

But there was always the nagging refrain, ``Why not do it all in
\texttt{bash} itself, using pattern matching?''. So, rather than
considering how to do this in \texttt{perl}, I hacked my way through
several iterations of trying to perform the substitution in
\texttt{bash} itself.

The expression \texttt{{[}A-Za-z0-9\_{]}} has a rather fortuitous
abbreviation as a POSIX character class in \texttt{bash}: it is denoted
by \texttt{{[}{[}:word:{]}{]}}. The pattern-matching/replacement
expression in \texttt{bash} therefore becomes:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#!/bin/bash}
\BuiltInTok{shopt} \AttributeTok{{-}s}\NormalTok{ extglob}

\VariableTok{filename}\OperatorTok{=}\StringTok{\textquotesingle{}El??Condor   \_Pasa\%\^{}!\textquotesingle{}}

\CommentTok{\#}
\CommentTok{\# The character class [:word:] includes all}
\CommentTok{\# alphanumeric characters and the underscore.}
\CommentTok{\# \^{}[:word:] is the negation of this condition.}
\CommentTok{\# So, we replace all non{-}alphanumeric characters and non{-}underscores}
\CommentTok{\# with the dash.}
\CommentTok{\#}
\VariableTok{newname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{filename}\OperatorTok{//}\PreprocessorTok{+(}\SpecialStringTok{[\^{}[:word:]]}\PreprocessorTok{)}\OperatorTok{/}\NormalTok{{-}}\VariableTok{\}}\StringTok{"}

\CommentTok{\#}
\CommentTok{\# We then extract the last character in the string newname}
\CommentTok{\# and check whether it matches the dash character.}
\CommentTok{\# If it does, we strip it off, to get the finalname.}
\CommentTok{\#}

\VariableTok{lastchar}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{:}\NormalTok{ {-}}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{if} \KeywordTok{[[} \StringTok{"}\VariableTok{$lastchar}\StringTok{"} \OtherTok{=\textasciitilde{}} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \KeywordTok{]]}
\ControlFlowTok{then}
  \VariableTok{finalname}\OperatorTok{=}\StringTok{"}\VariableTok{$\{newname}\OperatorTok{::}\NormalTok{{-}}\DecValTok{1}\VariableTok{\}}\StringTok{"}
\ControlFlowTok{fi}
\BuiltInTok{echo} \StringTok{"}\VariableTok{$finalname}\StringTok{"}
\end{Highlighting}
\end{Shaded}

The syntax for substring extraction in \texttt{bash} is
\texttt{\$\{parameter:offset:length\}} where \texttt{offset} is measured
starting from \texttt{0} at the extreme left
{[}\protect\hyperlink{ref-parametersubs}{7},\protect\hyperlink{ref-substring}{11},\protect\hyperlink{ref-stringops}{14}{]}.

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\item
  Note especially the space between the \texttt{:} and the \texttt{-} in
  the expression \texttt{"\$\{newname:\ -1\}"}. This space is inserted
  to avoid ambiguity with \emph{another} expression of the form
  \texttt{\$\{parameter:-word\}} which has a different function.
\item
  The final idiom used above is \texttt{"\$\{newname::-1\}"}, which is
  shorthand for \texttt{"\$\{newname:0:-1\}"}. This operation strips off
  the final character in the variable \texttt{"\$\{newname\}"}.
\end{enumerate}

\hypertarget{to-explore-further}{%
\subsection{To explore further}\label{to-explore-further}}

The interested reader is referred to the
\href{https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html\#Shell-Parameter-Expansion}{official
documentation online} for a comprehensive explanation of the dazzling
features of \emph{parameter expansion}
{[}\protect\hyperlink{ref-shellparamexp}{17}{]} and \emph{substring
removal} {[}\protect\hyperlink{ref-wikisubstring}{3}{]} in
\texttt{bash}. For an admirable summary of features like parameter
expansion, do also visit the clear and comprehensive
\href{https://mywiki.wooledge.org/BashGuide/Parameters}{BashGuide
website}.

If you are familiar with \texttt{bash} but require an
\href{https://www.thefreedictionary.com/aide+memoire}{aide-mémoire} for
some aspect of string matching or manipulation, the section with the
heading
\href{https://wiki.bash-hackers.org/start\#recommended_shell_resources}{``Recommended
Shell resources''} is the best place to start your search
{[}\protect\hyperlink{ref-bhwstart}{4}{]}. It contains a wealth of
authoritative links that will speedily dispel your doubts.

\hypertarget{feedback}{%
\subsection{Feedback}\label{feedback}}

Please \href{mailto:feedback.swanlotus@gmail.com}{email me} your
comments and corrections.

\noindent A PDF version of this article is
\href{./pattern-matching-in-bash.pdf}{available for download here}:

\begin{ttfamily}

\begin{small}

\url{https://swanlotus.netlify.app/blogs/pattern-matching-in-bash.pdf}

\end{small}

\end{ttfamily}

\hypertarget{bibliography}{%
\section*{References}\label{bibliography}}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\leavevmode\vadjust pre{\hypertarget{ref-gnupattern}{}}%
\CSLLeftMargin{{[}1{]} }%
\CSLRightInline{2022. Pattern matching. Retrieved 4 March 2023 from
\url{https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html}}

\leavevmode\vadjust pre{\hypertarget{ref-globhistory}{}}%
\CSLLeftMargin{{[}2{]} }%
\CSLRightInline{---. 2014. History of bash globbing. Retrieved 5 March
2023 from
\url{https://unix.stackexchange.com/questions/136353/history-of-bash-globbing}}

\leavevmode\vadjust pre{\hypertarget{ref-wikisubstring}{}}%
\CSLLeftMargin{{[}3{]} }%
\CSLRightInline{---. 2021. Parameter expansion {[}bash hackers wiki{]}.
Retrieved 5 March 2023 from
\url{https://wiki.bash-hackers.org/syntax/pe\#substring_removal}}

\leavevmode\vadjust pre{\hypertarget{ref-bhwstart}{}}%
\CSLLeftMargin{{[}4{]} }%
\CSLRightInline{---. 2023. The bash hackers wiki: Recommended shell
resources. Retrieved 5 March 2023 from
\url{https://wiki.bash-hackers.org/start\#recommended_shell_resources}}

\leavevmode\vadjust pre{\hypertarget{ref-wordsplitting}{}}%
\CSLLeftMargin{{[}5{]} }%
\CSLRightInline{lhunath aka Maarten Billemont and Greg Wooledge aka
GreyCat. 2018. Word splitting. Retrieved 5 March 2023 from
\url{https://mywiki.wooledge.org/WordSplitting?highlight=\%28spaces\%29\%7C\%28word\%29\%7C\%28splitting\%29}}

\leavevmode\vadjust pre{\hypertarget{ref-dottest}{}}%
\CSLLeftMargin{{[}6{]} }%
\CSLRightInline{Mark Byers. 2010. Test for a dot in bash. Retrieved 4
March 2023 from \url{https://stackoverflow.com/a/2745096}}

\leavevmode\vadjust pre{\hypertarget{ref-parametersubs}{}}%
\CSLLeftMargin{{[}7{]} }%
\CSLRightInline{Mendel Cooper. 2014. Parameter substitution. Retrieved 4
March 2023 from
\url{https://tldp.org/LDP/abs/html/parameter-substitution.html}}

\leavevmode\vadjust pre{\hypertarget{ref-introbashregex}{}}%
\CSLLeftMargin{{[}8{]} }%
\CSLRightInline{Zach Gollwitzer. 2020. Intro to bash regular
expressions. Retrieved 5 March 2023 from
\url{https://dev.to/zachgoll/intro-to-bash-regular-expressions-4d2p}}

\leavevmode\vadjust pre{\hypertarget{ref-posixcharclass}{}}%
\CSLLeftMargin{{[}9{]} }%
\CSLRightInline{Jan Goyvaerts. 2019. Regex tutorial---POSIX bracket
expressions. Retrieved 5 March 2023 from
\url{https://www.regular-expressions.info/posixbrackets.html}}

\leavevmode\vadjust pre{\hypertarget{ref-equaltilde}{}}%
\CSLLeftMargin{{[}10{]} }%
\CSLRightInline{Kusalananda. 2017. Bash test: What does "=~" do?
Retrieved 4 March 2023 from
\url{https://unix.stackexchange.com/a/340485/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-substring}{}}%
\CSLLeftMargin{{[}11{]} }%
\CSLRightInline{Linuxize. 2019. How to check if a string contains a
substring in bash. Retrieved 4 March 2023 from
\url{https://linuxize.com/post/how-to-check-if-string-contains-substring-in-bash/\#google_vignette}}

\leavevmode\vadjust pre{\hypertarget{ref-periodtest}{}}%
\CSLLeftMargin{{[}12{]} }%
\CSLRightInline{lmcanavals. 2013. Test if a string has a period in it
with bash. Retrieved 4 March 2023 from
\url{https://unix.stackexchange.com/a/63374/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-frazier2019}{}}%
\CSLLeftMargin{{[}13{]} }%
\CSLRightInline{Mitch Frazier. 2019. Pattern matching in bash. Retrieved
28 February 2023 from
\url{https://www.linuxjournal.com/content/pattern-matching-bash}}

\leavevmode\vadjust pre{\hypertarget{ref-stringops}{}}%
\CSLLeftMargin{{[}14{]} }%
\CSLRightInline{Cameron Newham and Bill Rosenblatt. 1998. String
operators. Retrieved 4 March 2023 from
\url{https://www.oreilly.com/library/view/learning-the-bash/1565923472/ch04s03.html}}

\leavevmode\vadjust pre{\hypertarget{ref-newham2005}{}}%
\CSLLeftMargin{{[}15{]} }%
\CSLRightInline{Cameron Newham and Bill Rosenblatt. 2005. \emph{Learning
the bash shell} (3rd ed.). O'Reilly.}

\leavevmode\vadjust pre{\hypertarget{ref-globbingref}{}}%
\CSLLeftMargin{{[}16{]} }%
\CSLRightInline{Gilles Quénot. 2023. Unix. Run script across multiple
dirs on specific files, where pathname has regex. Retrieved 5 March 2023
from \url{https://unix.stackexchange.com/a/738684/11610}}

\leavevmode\vadjust pre{\hypertarget{ref-shellparamexp}{}}%
\CSLLeftMargin{{[}17{]} }%
\CSLRightInline{Chet Ramey. 2020. Bash reference manual: Shell parameter
expansion. Retrieved 5 April 2023 from
\url{https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html\#Shell-Parameter-Expansion}}

\leavevmode\vadjust pre{\hypertarget{ref-bashscriptpatmatch}{}}%
\CSLLeftMargin{{[}18{]} }%
\CSLRightInline{Mark Reed. 2017. Bash script pattern matching. Retrieved
5 March 2023 from \url{https://stackoverflow.com/a/44688520}}

\leavevmode\vadjust pre{\hypertarget{ref-writeregexp}{}}%
\CSLLeftMargin{{[}19{]} }%
\CSLRightInline{Abhinav Tiwari. 2023. How to write regular
expressions?---GeeksforGeeks. Retrieved 5 March 2023 from
\url{https://www.geeksforgeeks.org/write-regular-expressions/}}

\leavevmode\vadjust pre{\hypertarget{ref-glob2023}{}}%
\CSLLeftMargin{{[}20{]} }%
\CSLRightInline{Wikipedia. 2023. Glob (programming). Retrieved 28
February 2023 from
\url{https://en.wikipedia.org/w/index.php?title=Glob_(programming)\&oldid=1133836865}}

\end{CSLReferences}



\end{document}
